{-
Author  : Pieter van Wyk
Created : 2020-12-09
Updated : 2020-12-10

Property tests for algorithm for solving set of
linear congruence equations of the form n = r_a (mod a),
                                        n = r_b (mod b).
-}
import LinearCongruence
import Test.QuickCheck

-- Helper Functions --
----------------------

-- divide out a factor from a number
divideOut :: Int -> Int -> Int
divideOut n num | n /= 1 && mod num n == 0 = divideOut n (div num n)
                | otherwise = num

-- generate list of odd prime factors (without repetition) of given number num
prime_odd :: Int -> Int -> [Int] -> [Int]
prime_odd num n acc_ls | num == 1       = acc_ls
                       | mod num n == 0 = prime_odd num' n acc_ls'
                       | otherwise      = prime_odd num (n+2) acc_ls
                       where
                         num'    = divideOut n num
                         acc_ls' = acc_ls ++ [n]

-- generate list of prime factors (without repetition) of given number
primeFact :: Int -> [Int]
primeFact num = primeFact' num []
  where primeFact' num acc | num == 1 = acc
                           | mod num 2 == 0 = let acc' = if elem 2 acc then acc else 2:acc
                                              in primeFact' (div num 2) acc'
                           | otherwise = prime_odd num 3 acc

-- helper function to determine if all elements in a list are coprime
checkCoprime :: [Int] -> Bool
checkCoprime [] = True
checkCoprime [_] = True
checkCoprime (n:ns) = all (\x -> gcd n x == 1) ns && checkCoprime ns

-- Property Tests --
--------------------

-- check if solutions found by solveCon satisfy the congruence equations
prop_lincon_00 :: Int -> Int -> Int -> Int -> Int -> Bool
prop_lincon_00 a b r_a r_b m = mod (n - r_a) a' == 0 && mod (n - r_b') b' == 0
  where a' = max (abs a) 1 -- use positive integer greater than 0 for a', b'
        b' = max (abs b) 1
        d = gcd a' b'
        r_b' = (max m 1)*d + r_a -- ensure d divides r_b' - r_a
        n = solveCon a' b' r_a r_b'

-- check if all possible solutions generated from a*x + b*y = r_b - r_a
-- satisfy the congruence equations
prop_lincon_01 :: Int -> Int -> Int -> Int -> Int -> Int -> Bool
prop_lincon_01 a b r_a r_b m t = mod (n_t - r_a) a' == 0 && mod (n_t - r_b') b' == 0
  where a' = max (abs a) 1
        b' = max (abs b) 1
        d = gcd a' b'
        r_b' = (max m 1)*d + r_a
        n = solveCon a' b' r_a r_b'
        n_t = n - div (t * a' * b') d

-- check if different solutions of congruence equations satisfy
-- Chinese remainder Theorem
prop_lincon_02 :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Bool
prop_lincon_02 a b r_a r_b m t1 t2 = mod (n_t1 - n_t2) (lcm a' b') == 0
  where a' = max (abs a) 1
        b' = max (abs b) 1
        d = gcd a' b'
        r_b' = (max m 1)*d + r_a
        n = solveCon a' b' r_a r_b'
        n_t1 = n - div (t1 * a' * b') d
        n_t2 = n - div (t2 * a' * b') d

-- for a given number num and its factor n, check that
-- after n is not a factor of the result of divideOut
prop_divideOut_00 :: Int -> Int -> Bool
prop_divideOut_00 n num = mod (divideOut n' num') n' /= 0
  where n' = max 2 (abs n)
        num' = max 1 (abs num)

-- check that for any list generated by primeFact, all elements are coprime
prop_primeFact_00 :: Int -> Bool
prop_primeFact_00 num = checkCoprime (primeFact num')
  where num' = max 2 (abs num)

main = do
  quickCheck (withMaxSuccess 10000 prop_lincon_00)
  quickCheck (withMaxSuccess 10000 prop_lincon_01)
  quickCheck (withMaxSuccess 10000 prop_lincon_02)
  quickCheck (withMaxSuccess 10000 prop_divideOut_00)
  quickCheck (withMaxSuccess 10000 prop_primeFact_00)
